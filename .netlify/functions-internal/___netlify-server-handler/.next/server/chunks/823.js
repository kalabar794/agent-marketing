"use strict";exports.id=823,exports.ids=[823],exports.modules={75823:(a,b,c)=>{c.d(b,{KA:()=>B});var d=a=>"string"==typeof a?a:JSON.stringify(a),e=globalThis.Buffer?a=>Buffer.from(a,"base64").toString():a=>atob(a),f=globalThis.Buffer?a=>Buffer.from(d(a)).toString("base64"):a=>btoa(d(a));c(19771);var g=()=>{let{Deno:a,Netlify:b,process:c}=globalThis;return b?.env??a?.env??{delete:a=>delete c?.env[a],get:a=>c?.env[a],has:a=>!!c?.env[a],set:(a,b)=>{c?.env&&(c.env[a]=b)},toObject:()=>c?.env??{}}},h=class extends Error{constructor(a){super(`The environment has not been configured to use Netlify Blobs. To use it manually, supply the following properties when creating a store: ${a.join(", ")}`),this.name="MissingBlobsEnvironmentError"}},i="b64;",j="x-amz-meta-user",k="netlify-blobs-metadata",l=a=>{if(!a.headers)return{};let b=a.headers.get(k)||a.headers.get(j);try{return(a=>a?.startsWith(i)?JSON.parse(e(a.slice(i.length))):{})(b)}catch{throw Error("An internal error occurred while trying to retrieve the metadata for an entry. Please try updating to the latest version of the Netlify Blobs client.")}},m="x-nf-request-id",n=class extends Error{constructor(a){let b=a.headers.get("x-nf-error")||`${a.status} status code`;a.headers.has(m)&&(b+=`, ID: ${a.headers.get(m)}`),super(`Netlify Blobs has generated an internal error (${b})`),this.name="BlobsInternalError"}},o=async a=>{let b=[];for await(let c of a)b.push(c);return b},p=class extends Error{constructor(){super("Netlify Blobs has failed to perform a read using strong consistency because the environment has not been configured with a 'uncachedEdgeURL' property"),this.name="BlobsConsistencyError"}},q={"us-east-1":!0,"us-east-2":!0,"eu-central-1":!0,"ap-southeast-1":!0,"ap-southeast-2":!0},r=class extends Error{constructor(a){super(`${a} is not a supported Netlify Blobs region. Supported values are: ${Object.keys(q).join(", ")}.`),this.name="InvalidBlobsRegionError"}},s="test"===g().get("NODE_ENV")?1:5e3,t=5,u=async(a,b,c,d=t)=>{try{let e=await a(b,c);if(d>0&&(429===e.status||e.status>=500)){let f=v(e.headers.get("X-RateLimit-Reset"));return await w(f),u(a,b,c,d-1)}return e}catch(f){if(0===d)throw f;let e=v();return await w(e),u(a,b,c,d-1)}},v=a=>a?Math.max(1e3*Number(a)-Date.now(),1e3):s,w=a=>new Promise(b=>{setTimeout(b,a)}),x=class{constructor({apiURL:a,consistency:b,edgeURL:c,fetch:d,region:e,siteID:f,token:g,uncachedEdgeURL:h}){if(this.apiURL=a,this.consistency=b??"eventual",this.edgeURL=c,this.fetch=d??globalThis.fetch,this.region=e,this.siteID=f,this.token=g,this.uncachedEdgeURL=h,!this.fetch)throw Error("Netlify Blobs could not find a `fetch` client in the global scope. You can either update your runtime to a version that includes `fetch` (like Node.js 18.0.0 or above), or you can supply your own implementation using the `fetch` property.")}async getFinalRequest({consistency:a,key:b,metadata:c,method:d,parameters:e={},storeName:g}){let h=(a=>{if(!a)return null;let b=f(JSON.stringify(a)),c=`b64;${b}`;if(k.length+c.length>2048)throw Error("Metadata object exceeds the maximum size");return c})(c),i=a??this.consistency,l=`/${this.siteID}`;if(g&&(l+=`/${g}`),b&&(l+=`/${b}`),this.edgeURL){if("strong"===i&&!this.uncachedEdgeURL)throw new p;let a={authorization:`Bearer ${this.token}`};h&&(a[j]=h),this.region&&(l=`/region:${this.region}${l}`);let b=new URL(l,"strong"===i?this.uncachedEdgeURL:this.edgeURL);for(let a in e)b.searchParams.set(a,e[a]);return{headers:a,url:b.toString()}}let m={authorization:`Bearer ${this.token}`},o=new URL(`/api/v1/blobs${l}`,this.apiURL??"https://api.netlify.com");for(let a in e)o.searchParams.set(a,e[a]);if(this.region&&o.searchParams.set("region",this.region),void 0===g||void 0===b||(h&&(m[k]=h),"head"===d||"delete"===d))return{headers:m,url:o.toString()};let q=await this.fetch(o.toString(),{headers:{...m,accept:"application/json;type=signed-url"},method:d});if(200!==q.status)throw new n(q);let{url:r}=await q.json();return{headers:h?{[j]:h}:void 0,url:r}}async makeRequest({body:a,conditions:b={},consistency:c,headers:d,key:e,metadata:f,method:g,parameters:h,storeName:i}){let{headers:j={},url:k}=await this.getFinalRequest({consistency:c,key:e,metadata:f,method:g,parameters:h,storeName:i}),l={...j,...d};"put"===g&&(l["cache-control"]="max-age=0, stale-while-revalidate=60"),"onlyIfMatch"in b&&b.onlyIfMatch?l["if-match"]=b.onlyIfMatch:"onlyIfNew"in b&&b.onlyIfNew&&(l["if-none-match"]="*");let m={body:a,headers:l,method:g};return a instanceof ReadableStream&&(m.duplex="half"),u(this.fetch,k,m)}},y=(a,b)=>{let c,d=b??(()=>{let a=globalThis.netlifyBlobsContext||g().get("NETLIFY_BLOBS_CONTEXT");if("string"!=typeof a||!a)return{};let b=e(a);try{return JSON.parse(b)}catch{}return{}})(),f=d.siteID??a.siteID,i=d.token??a.token;if(!f||!i)throw new h(["siteID","token"]);if(void 0!==a.region&&(c=a.region,!Object.keys(q).includes(c)))throw new r(a.region);return{apiURL:d.apiURL??a.apiURL,consistency:a.consistency,edgeURL:d.edgeURL??a.edgeURL,fetch:a.fetch,region:a.region,siteID:f,token:i,uncachedEdgeURL:d.uncachedEdgeURL??a.uncachedEdgeURL}},z="netlify-internal/legacy-namespace/",A=class a{constructor(b){if(this.client=b.client,"deployID"in b){a.validateDeployID(b.deployID);let c="deploy:"+b.deployID;b.name&&(c+=`:${b.name}`),this.name=c}else if(b.name.startsWith(z)){let c=b.name.slice(z.length);a.validateStoreName(c),this.name=c}else a.validateStoreName(b.name),this.name="site:"+b.name}async delete(a){let b=await this.client.makeRequest({key:a,method:"delete",storeName:this.name});if(![200,204,404].includes(b.status))throw new n(b)}async get(a,b){let{consistency:c,type:d}=b??{},e=await this.client.makeRequest({consistency:c,key:a,method:"get",storeName:this.name});if(404===e.status)return null;if(200!==e.status)throw new n(e);if(void 0===d||"text"===d)return e.text();if("arrayBuffer"===d)return e.arrayBuffer();if("blob"===d)return e.blob();if("json"===d)return e.json();if("stream"===d)return e.body;throw new n(e)}async getMetadata(a,{consistency:b}={}){let c=await this.client.makeRequest({consistency:b,key:a,method:"head",storeName:this.name});if(404===c.status)return null;if(200!==c.status&&304!==c.status)throw new n(c);let d=c?.headers.get("etag")??void 0;return{etag:d,metadata:l(c)}}async getWithMetadata(a,b){let{consistency:c,etag:d,type:e}=b??{},f=await this.client.makeRequest({consistency:c,headers:d?{"if-none-match":d}:void 0,key:a,method:"get",storeName:this.name});if(404===f.status)return null;if(200!==f.status&&304!==f.status)throw new n(f);let g={etag:f?.headers.get("etag")??void 0,metadata:l(f)};if(304===f.status&&d)return{data:null,...g};if(void 0===e||"text"===e)return{data:await f.text(),...g};if("arrayBuffer"===e)return{data:await f.arrayBuffer(),...g};if("blob"===e)return{data:await f.blob(),...g};if("json"===e)return{data:await f.json(),...g};if("stream"===e)return{data:f.body,...g};throw Error(`Invalid 'type' property: ${e}. Expected: arrayBuffer, blob, json, stream, or text.`)}list(a={}){let b=this.getListIterator(a);return a.paginate?b:o(b).then(a=>a.reduce((a,b)=>({blobs:[...a.blobs,...b.blobs],directories:[...a.directories,...b.directories]}),{blobs:[],directories:[]}))}async set(b,c,d={}){a.validateKey(b);let e=a.getConditions(d),f=await this.client.makeRequest({conditions:e,body:c,key:b,metadata:d.metadata,method:"put",storeName:this.name}),g=f.headers.get("etag")??"";if(e)return 412===f.status?{modified:!1}:{etag:g,modified:!0};if(200===f.status)return{etag:g,modified:!0};throw new n(f)}async setJSON(b,c,d={}){a.validateKey(b);let e=a.getConditions(d),f=JSON.stringify(c),g=await this.client.makeRequest({...e,body:f,headers:{"content-type":"application/json"},key:b,metadata:d.metadata,method:"put",storeName:this.name}),h=g.headers.get("etag")??"";if(e)return 412===g.status?{modified:!1}:{etag:h,modified:!0};if(200===g.status)return{etag:h,modified:!0};throw new n(g)}static formatListResultBlob(a){return a.key?{etag:a.etag,key:a.key}:null}static getConditions(a){if("onlyIfMatch"in a&&"onlyIfNew"in a)throw Error("The 'onlyIfMatch' and 'onlyIfNew' options are mutually exclusive. Using 'onlyIfMatch' will make the write succeed only if there is an entry for the key with the given content, while 'onlyIfNew' will make the write succeed only if there is no entry for the key.");if("onlyIfMatch"in a&&a.onlyIfMatch){if("string"!=typeof a.onlyIfMatch)throw Error("The 'onlyIfMatch' property expects a string representing an ETag.");return{onlyIfMatch:a.onlyIfMatch}}if("onlyIfNew"in a&&a.onlyIfNew){if("boolean"!=typeof a.onlyIfNew)throw Error("The 'onlyIfNew' property expects a boolean indicating whether the write should fail if an entry for the key already exists.");return{onlyIfNew:!0}}}static validateKey(a){if(""===a)throw Error("Blob key must not be empty.");if(a.startsWith("/")||a.startsWith("%2F"))throw Error("Blob key must not start with forward slash (/).");if(new TextEncoder().encode(a).length>600)throw Error("Blob key must be a sequence of Unicode characters whose UTF-8 encoding is at most 600 bytes long.")}static validateDeployID(a){if(!/^\w{1,24}$/.test(a))throw Error(`'${a}' is not a valid Netlify deploy ID.`)}static validateStoreName(a){if(a.includes("/")||a.includes("%2F"))throw Error("Store name must not contain forward slashes (/).");if(new TextEncoder().encode(a).length>64)throw Error("Store name must be a sequence of Unicode characters whose UTF-8 encoding is at most 64 bytes long.")}getListIterator(b){let{client:c,name:d}=this,e={};return b?.prefix&&(e.prefix=b.prefix),b?.directories&&(e.directories="true"),{[Symbol.asyncIterator](){let b=null,f=!1;return{async next(){if(f)return{done:!0,value:void 0};let g={...e};null!==b&&(g.cursor=b);let h=await c.makeRequest({method:"get",parameters:g,storeName:d}),i=[],j=[];if(![200,204,404].includes(h.status))throw new n(h);if(404===h.status)f=!0;else{let c=await h.json();c.next_cursor?b=c.next_cursor:f=!0,i=(c.blobs??[]).map(a.formatListResultBlob).filter(Boolean),j=c.directories??[]}return{done:!1,value:{blobs:i,directories:j}}}}}}}},B=a=>{if("string"==typeof a)return new A({client:new x(y({})),name:a});if("string"==typeof a?.name&&"string"==typeof a?.siteID&&"string"==typeof a?.token){let{name:b,siteID:c,token:d}=a,e=y(a,{siteID:c,token:d});if(!b||!c||!d)throw new h(["name","siteID","token"]);return new A({client:new x(e),name:b})}if("string"==typeof a?.name){let{name:b}=a,c=y(a);if(!b)throw new h(["name"]);return new A({client:new x(c),name:b})}if("string"==typeof a?.deployID){let b=y(a),{deployID:c}=a;if(!c)throw new h(["deployID"]);return new A({client:new x(b),deployID:c})}throw Error("The `getStore` method requires the name of the store as a string or as the `name` property of an options object")}}};